---
title: "Phylogenetic mixed model"
author: "Geir Bolstad"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Phylogenetic mixed model}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

# The `Almer` function

The `Almer` function is a modification/hack of the `lmer` function in the `lme4`package to incorporate correlated effects in the random structure. The `Almer` function can be used to fit phylogenetic mixed models.  
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

To start with, we need an ultrametric phylogeny of unit depth. We can construct this, for example, using the function `rtree` of the `ape` package.
```{r}
n_species <- 100
tree <- ape::rtree(n = n_species)
tree <- ape::chronopl(tree, lambda = 1)
```

From this we can make the phylogenetic relatedness matrix A.
```{r}
A <- Matrix::Matrix(ape::vcv(tree), sparse = TRUE)
```

The columnames of A must be the species identifier.
```{r}
colnames(A) <- rownames(A) <- paste("species", 1:n_species, sep = "_")
```

From this we can simulate a Browninan motion process and add some residual noise.
```{r}
y <- 5 + t(chol(A))%*%rnorm(n_species, 0, 2) + # BM process with mean 5 and s.d. 2
     rnorm(n_species, 0, 1)                    # residual variation with s.d. 1
```

For `Almer` to work, the data must have the species identifier in addition to the species means.
```{r}
dt <- data.frame(species = colnames(A),
                 y = as.vector(y))
```

`Almer` can then be used to estimate the means and variances of the process.
```{r}
mod <- Almer(y ~ 1 + (1|species), data = dt, A = list(species = A))
summary(mod)
```

The `Almer` function is flexible as it is based on the lmer function, and can include additional fixed and random effects on top of the phylogenetic effects. Alo, it is not restricted to phylogeny related problems, for example it can be used to estimate additive gentic variances and/or dominance variances (the argument A list can have several entries).

# The `Almer_SE` function
This function extends the Almer function by allowing the inclusion of uncertainty of the species means. To do this, we take advantage of how weights are included in the `lmer` function: the diagonal of the residual covariance matrix is the residual variance parameter $\sigma^2$ times the vector of inverse weights. By using weights equal to $1/(1+SE^2/\sigma^2)$, where SE is a vector of standard errors, the diagonal of the residual covariance matrix is $\sigma^2 + SE^2$. Because the weights includes the residual variance parameter, the function uses an itarative approach.   
  
To illustrate the approach, we start with adding some arbitrary SE values to the data

```{r}
dt$SE <- runif(nrow(dt), min = 0.1, max = 0.2) 
```

`Almer_SE` can then be used to estimate the means and variances of the process taking the unceratinty into account.

```{r}
mod_SE <- Almer_SE(y ~ 1 + (1|species), data = dt, SE = dt$SE, A = list(species = A))
summary(mod_SE)
```

Note that the estimated residual vairance represent the residual variance after correcting for the uncertainty in the means.


# Simulating data from the fitted model
The `Almer_sim` function can be used to simulate the responses, in our case species means, of the fitted models of both `Almer` and `Almer_SE`. Note that the `simulate.merMod` function did not seem to work properly when the number of random effects equal the number of observations.
```{r}
sim_y <- Almer_sim(mod_SE, nsim = 3)
sim_y[1:3,]
```

This can further be used to do bootsrapping
```{r, eval = FALSE}
dt$group <- c(rep("A", 50), rep("B", 50))
mod <- Almer(y ~ group + (1|species), data = dt, A = list(species = A))
#mod <- Almer(y ~ 1 + (1|species), data = dt, A = list(species = A))
nsim = 3
y <- Almer_sim(mod, nsim)
dt <- mod@frame
boot <- apply(y, 2, function(x){
  dt$hopefullynotavariablealready <- x
  update(mod, hopefullynotavariablealready ~ ., data = dt)
})
fixef_boot <- sapply(boot, lme4::fixef)
if(is.vector(fixef_boot)){
  fixef_boot <- cbind(fixef_boot)
}else fixef_boot <- t(fixef_boot)
colnames(fixef_boot) <- names(lme4::fixef(boot[[1]]))

VarCorr_list <- lapply(boot, function(x) as.data.frame(lme4::VarCorr(x))) 
vcov_boot <- t(sapply(VarCorr_list, function(x) x$vcov))
colnames(vcov_boot) <- VarCorr_list[[1]]$grp

list(
  fixef = cbind(mean = apply(fixef_boot, 2, mean), 
      std.err. = apply(fixef_boot, 2, sd), 
      "2.5% quantile" = apply(fixef_boot, 2, quantile, probs = 0.025),
      "97.5% quantile" = apply(fixef_boot, 2, quantile, probs = 0.975)
      ),
  vcov = cbind(mean = apply(vcov_boot, 2, mean), 
      std.err. = apply(vcov_boot, 2, sd), 
      "2.5% quantile" = apply(vcov_boot, 2, quantile, probs = 0.025),
      "97.5% quantile" = apply(vcov_boot, 2, quantile, probs = 0.975)
      ),
  models <- boot)


```




# Phylogenetic heritability
The phylH function can be used to estimate the phylogenetic heritability of a object fitted by Almer. The 95% confidence interval is estimated by bootstrapping. The name of the numerator of the heritability, and unless the phylogenetic residual is estiamted as residuals in the model fit, the name of the phylogenetic residuals also needs to be given.  

```{r}
phylH(mod, numerator = "species", nsim = 3)
```


