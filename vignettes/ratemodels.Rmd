---
title: "Rate models"
author: "Geir Bolstad"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(evolvability)
```

This vignette shows how to use the `rate_gls` function. This function can fit three different types of evolutionary models depending on the `model` argument of the function. In all models the evolutionary rate of change in the y-variable is a function of the state of the predictor x. It can be used to test hypotesis about the effect of an evolving trait (x) on the rate of evolution in a different trait (y). The different evolutionary models are outlined below. However, to simulate data for the different evolutionary models, we first need an ultrametric phylogeny.

```{r}
tree <- geiger::sim.bdtree(b = 1, d = 0, n = 100, t = 4)
ape::is.ultrametric(tree)
```

We scale the tree to unit length between root and tips. (This makes the parameters easier to interpret)
```{r}
tree$edge.length <- tree$edge.length/diag(ape::vcv(tree))[1]
```

# Predictor as Brownian motion 
The first model is a model where the predictor $x$ evolves according to a Brownian motion (BM) process, the evolutionary model is 

$$dy = \sqrt{a + bx} dW_i $$

$$dx = \sigma dW_i $$
where the $dW_i$ are uncorrelated white noise. This means that $y$ is following a Brownian motion with variance linear in $x$, and $x$ itself is assumed to follow a standard Brownian motion with variance $\sigma^2$. The influence of $x$ is characterized by the parameter $b$. This model will break down when $a + bx$ becomes negative, and should be seen as an approximation that may be valid for a given range of $x$ values as spanned by the species to be used in the analysis. Using the function `simulate_rate` with `model = "predictor_BM"` we can simulate data with different parameter values.
```{r}
sim_data <- simulate_rate(tree, startv_x=0, sigma_x=1, a=2, b=1, model = "predictor_BM")
```
In this simulation often gives a warning message because the rate parameter, a + bx, is negative. In these instances, the rate parameter is assignd the value 0 in the simulaiton. As long as the number of these instances is low, this should not be a problem.   
We can now fit the gls model to these data
```{r}
gls_mod <- rate_gls(x=sim_data$x, y=sim_data$y, species=sim_data$species, tree, model = "predictor_BM", maxiter = 100, silent = TRUE)
gls_mod$param
```
This gives the parameters of the model. The parameters "Intercept (A)" and "Slope (B)" gives the gls estimates of the regression of y^2^ on x. The a, b and Sigma2_x are the parameters of the evolutonary model. The standard error of the estimates does not take into account the error in Sigma2_x. Parametric boostrapping can be used to get 95% confidence intervals taking into account error in the entire process (assuming that the phylogenetic tree is true).
```{r}
boot_rate_gls(gls_mod, n = 5) # when doing a proper boostrap n should be larger n>999
```
Plotting the the generalized least squares regression with $y^2$ on the y-axis (i.e. on the variance scale). 
```{r}
plot(gls_mod, scale = "VAR")
```
Alternatively we can plot the regression with with $|y|$ on the y-axis (i.e. on the standard deviation scale). This is the default of the plot function. 
```{r}
plot(gls_mod) # with the default scale == "SD"
```
 
# Predictor as geometric Brownian motion


# Predictor affects rates of recent evolution
EVOLUTIONARY MODEL

Simulating data
```{r}
sim_data <- simulate_rate(tree, startv_x=0, sigma_x=1, a=3, b=1, sigma_y = 2, model = "recent_evol")
```

Fitting the GLS model
```{r}
gls_mod <- rate_gls(x=sim_data$x, y=sim_data$y, species=sim_data$species, tree, model = "recent_evol", maxiter = 1000, silent = TRUE, useLFO = FALSE)
gls_mod$param
```

```{r}
# boot_rate_gls(gls_mod, n = 5, useLFO = FALSE) 
# when doing a proper boostrap n should be larger n>999

```

```{r}
plot(gls_mod, scale = "VAR")
```


# Extra stuff
```{r TESTING rate_gls recent_evol, eval = FALSE}
#### recent_evol ##
# Testing the estimation of b
b_true <- c(1:100)/50
b_est <- NA
for(i in 1:length(a_true)){
  sim_data <- try(simulate_rate(tree, startv_x=0, sigma_x=3, a=10, b=b_true[i], sigma_y = 2, 
                                model = "recent_evol"), TRUE)
  if(is.null(nrow(sim_data))){
    b_est[i] <- NA
  }else{
    gls_mod <- try(rate_gls(x=sim_data$x, y=sim_data$y, species=sim_data$species, tree, model = "recent_evol",
                        maxiter = 1000, silent = TRUE, useLFO = FALSE), TRUE)
    if(length(gls_mod) == 1){
      b_est[i] <- NA
    }else{
      if(gls_mod$convergence != "Convergence"){
        b_est[i] <- NA
      }else{
        b_est[i] <- gls_mod$param["b",1]
      }
    }
  }
}

plot(b_true, b_est)
abline(0,1)
abline(lm(b_est~b_true), lty = "dashed")
#lm(b_est~b_true) # this is good

# Testing the estimation of a
a_true <- c(1:100)/25
a_est <- NA
for(i in 1:length(a_true)){
  sim_data <- try(simulate_rate(tree, startv_x=0, sigma_x=3, a=a_true[i], b=0, sigma_y = 2, 
                                model = "recent_evol"), TRUE)
  if(is.null(nrow(sim_data))){
    a_est[i] <- NA
  }else{
    gls_mod <- try(rate_gls(x=sim_data$x, y=sim_data$y, species=sim_data$species, tree, model = "recent_evol",
                        maxiter = 1000, silent = TRUE, useLFO = FALSE), TRUE)
    if(length(gls_mod) == 1){
      a_est[i] <- NA
    }else{
      if(gls_mod$convergence != "Convergence"){
        a_est[i] <- NA
      }else{
        a_est[i] <- gls_mod$param["a",1]
      }
    }
  }
}
plot(a_true, a_est)
abline(0,1)
abline(lm(a_est~a_true), lty = "dashed")

#lm(a_est~a_true) # this is good

```

```{r TESTING GLS, eval=FALSE}
n = 100
tree <- geiger::sim.bdtree(b = 1, d = 0, n = n, t = 4)
#ape::is.ultrametric(tree)
tree$edge.length <- tree$edge.length/diag(ape::vcv(tree))[1]
A <- ape::vcv(tree)
y <- t(chol(A))%*%rnorm(n)
X <- cbind(rep(1, n))

system.time(GLS(y=y, X = X, R=A, coef_only = TRUE))
system.time(GLS(y=y, X = X, R=A, coef_only = FALSE))

mod <- GLS(y=y, X = X, R=A)
mod$coef
solve(t(X)%*%solve(A)%*%X)%*%t(X)%*%solve(A)%*%y # the standard GLS equation gives the same

mod$sigma2 # this gives the diffusion variance
var(solve(t(chol(A)))%*%y)  # gives the same

mod$GSSE #generalized sum of squares
t(y-X%*%mod$coef[1])%*%solve(A)%*%(y-X%*%mod$coef[1]) # the standard GLS equation gives the same

# also checking if Almer gives similar
dimnames(A)
ind <- colnames(A)
Almer(y~1 + (1|ind), A = list(ind = Matrix::Matrix(A, sparse = TRUE))) #gives very similar results

```



```{r plot of change in variance, eval=FALSE}

tree <- geiger::sim.bdtree(b = 1, d = 0, n = 100, t = 4)
ape::is.ultrametric(tree)
tree$edge.length <- tree$edge.length/diag(ape::vcv(tree))[1]
sim_data <- simulate_rate(tree, startv_x=0, sigma_x=1, a=2, b=1, model = "predictor_BM")
gls_mod <- rate_gls(x=sim_data$x, y=sim_data$y, species=sim_data$species, tree, model = "predictor_BM", maxiter = 100, silent = TRUE)
gls_mod$Rsquared
invchol_R <- solve(t(chol(gls_mod$R))) #cholescky decomposition of the residual covariance matrix
y2_star <- invchol_R%*%gls_mod$data$y2 # linearly transformed y-squared values
X <- cbind(rep(1, length(gls_mod$data$y2)), gls_mod$data$x) # design matrix of the regression
X_star <- invchol_R%*%X # linearly transfomred design matrix
mod <- lm.fit(X_star, y2_star) #fitting a linear model with the transformed y2 and X
mod$coef # should give the same values as the gls_mod intercept and slope (and the same R squared)
gls_mod$param
# we now look at outliers by plotting the residuals + effect of transformed x on transformed x
plot(X_star[,2], mod$residuals + mod$coef[2]*X_star[,2])
abline(0, mod$coef[2])


```



```{r TESTING macro_pred, eval = FALSE}

n = 500
tree <- geiger::sim.bdtree(b = 1, d = 0, n = n, t = 4)
#ape::is.ultrametric(tree)
tree$edge.length <- tree$edge.length/diag(ape::vcv(tree))[1]
A <- ape::vcv(tree)
V <- A
V <- Matrix::Matrix(V, sparse = TRUE)

y <- t(chol(V))%*%rnorm(n)

system.time(y_pred <- macro_pred(y, V, useLFO = FALSE))
  #  user  system elapsed 
  # 7.511   0.178   7.732 
plot(y, y_pred)
abline(0,1)

V <- diag(20)# Matrix::Matrix(diag(20))
Matrix::solve(V)
y_pred <- macro_pred(y, V, useLFO = FALSE)

terminal.edges<-matrix(NA,length(tree$tip.label))
terminal.edges<-tree$edge.length[tree$edge[1:(2*length(tree$tip.label)-2),2]<=length(tree$tip.label)]
plot(terminal.edges, abs(y_pred-y))

# cecking the 




```




# old stuff


```{r, eval = FALSE}
# testing the R2 values

# star phylogeny:
tree <- phytools::starTree(1:100, rep(1, 100))

# predictor_BM model
mod <- simulate_rate(tree, startv_x=0, sigma_x=1, a=2, b=1, model = "predictor_BM")
gls_mod <- rate_gls(x=mod$x, y=mod$y, species=tree$tip.label, tree, model = "predictor_BM", maxiter = 100, silent = FALSE)
gls_mod$Rsquared
summary(lm(gls_mod$data$y2~gls_mod$data$x))$r.squared

plot(gls_mod)

X <- simulate(gls_mod, nsim = 10)


# predictor_geometricBM model
mod <- rate_sim(tree, startv_x=1, sigma_x=1, a=2, b=1, model = "predictor_geometricBM")
gls_mod <- rate_gls(x=mod$x, y=mod$y, species=tree$tip.label, tree, model = "predictor_geometricBM", maxiter = 100, silent = FALSE)
gls_mod$Rsquared
summary(lm(gls_mod$data$y2~gls_mod$data$x))$r.squared

# residual_rate model
# This one should not be exactly equal
mod <- rate_sim(tree, startv_x=0, sigma_x=1, a=2, b=1, model = "residual_rate")
gls_mod <- rate_gls(x=mod$x, y=mod$y, species=tree$tip.label, tree, model = "residual_rate", maxiter = 100, silent = FALSE)
gls_mod$Rsquared
summary(lm(gls_mod$data$y2~gls_mod$data$x))$r.squared

# R2 in ideal situation:
n <- 100000  #total sample size
x <- rep(c(0,1), each = n/2)
y <- c(rnorm(n/2, 0, 1), rnorm(n/2, 0, sqrt(2)))
summary(lm(y^2 ~ x))$r.squared

plot(x, y^2)

tree <- phytools::starTree(1:n, rep(1, n))
gls_mod <- rate_gls(x=x, y=y, species=tree$tip.label, tree, model = "predictor_BM", maxiter = 100, silent = FALSE)
gls_mod$Rsquared
summary(lm(gls_mod$data$y2~gls_mod$data$x))$r.squared
# NB this is half of what Thomas derived analytically

# analytic derivation:
# within group var for y^2 is 2*var(y)^2 (derivated from results in Bohrnstedt and Goldberger 1969 + fourth moment of normal = 3*var[y]^2)
# avarage within group variation is 
mean(c(2*1, 2*(2^2))) # = 5
# mean of the two grups are 1 and sqrt(2)
# the between group mean square is 
((2-1)/2)^2 # = 0.25
# R2 is
1 - 5/(5+0.25)
1/21

```


```{r, eval = FALSE}

# testing:
tree <- geiger::sim.bdtree(b = 1, d = 0, n = 100, t = 4)
tree$edge.length <- tree$edge.length/diag(ape::vcv(tree))[1]

mod <- rate_sim(tree, startv_x=3, sigma_x=1, a= 0.001, b=1, model = "predictor_geometricBM")

#mod$y <- mod$y + rnorm(length(mod$y))


gls_mod <- rate_gls(x=mod$x, y=mod$y, species=tree$tip.label, tree, model = "predictor_geometricBM", maxiter = 100, silent = FALSE)


gls_mod$param["a",1]

rate_sim()


A <-ape::vcv(tree)
C <- t(chol(A))
R <- diag(ncol(A))*1

sigma_x <- var(solve(C)%*%mod$x)

Ainv <- solve(A)
Rinv <- solve(R)

x1 <- solve(C)%*%(mod$x-mean(mod$x))
x2 <- solve(Rinv+solve(c(sigma_x)*A))%*%Rinv%*%(mod$x-mean(mod$x))
x3 <- (A-solve(diag(x = diag(Ainv))))%*%Ainv%*%(mod$x-mean(mod$x))
x4 <- A%*%solve(A+R)%*%(mod$x-mean(mod$x))
  
plot(x2, x4)
plot(mod$x, x4)
  
plot(solve(C)%*%mod$x, solve(Rinv+solve(c(sigma_x)*A))%*%Rinv%*%(mod$x-mean(mod$x)))

plot(solve(C)%*%mod$x, (A-solve(diag(x = diag(Ainv))))%*%Ainv%*%(mod$x-mean(mod$x)))


#### testing almer
tree <- geiger::sim.bdtree(b = 1, d = 0, n = 100, t = 4)
tree$edge.length <- tree$edge.length/diag(ape::vcv(tree))[1]
mod <- rate_sim(tree, startv_x=3, sigma_x=1, a= 0.001, b=1)
A <- Matrix::Matrix(ape::vcv(tree), sparse = TRUE)
#A <- as(A, "dgCMatrix")
# colnames(A) <- paste("q", 1:100)
# rownames(A) <- paste("q", 1:100)
dt <- data.frame(species = paste("s", mod$species, sep = ""),
                 x = mod$x)

Almer(formula = x ~ 1 + (1|species), data = dt, A = list(species = A))
A <- A[100-0:99, 100-0:99]
Almer(formula = x ~ 1 + (1|species), data = dt, A = list(species = A))

mod <- Almer(formula = x ~ 1 + (1|species), data = dt, A = list(species = A))


##### residual rate simulation #####
b_true <- (1:100)/20
b_est <- NA
for(i in 1:length(b_true)){
  n <- 200
  tree <- geiger::sim.bdtree(b = 1, d = 0, n = n, t = 4)
  tree$edge.length <- tree$edge.length/diag(ape::vcv(tree))[1]
  
  x <- exp(rnorm(n))
  
  dt <- rate_sim(tree, a = 1, b = b_true[i], x = x, model = "residual_rate")
  mod <- rate_gls(x=dt$x, y=dt$y, species=dt$species, tree, model = "residual_rate", maxiter = 100, silent = FALSE, 
                      startv = list(a=NULL, b=NULL))
  if(mod$convergence == "Convergence") b_est[i] <- mod$param["b", 1]
  else b_est[i] <- NA
  
}

plot(b_true, b_est)
abline(0,1)
abline(lm(b_est~b_true[1:length(b_est)]))


mod$param

boot.rate_gls(mod)

```


